using UnityEngine;

public class EventGradientController : MonoBehaviour
{
    [SerializeField] private SpriteRenderer spriteRenderer;

    private static readonly int size = 256;

    private Texture2D currentTex = null;

    public void UpdateGradientData(MapEvent.ChromaGradient gradient)
    {
        if (currentTex != null)
        {
            Destroy(currentTex);
        }
        RegenerateTexture(gradient);
    }

    public void UpdateDuration(float duration)
    {
        transform.localScale = new Vector3(duration * EditorScaleController.EditorScale * (-4f/3), size, 1);
    }

    public void SetVisible(bool visible) => spriteRenderer.enabled = visible;

    /// <summary>
    /// Taken and modified from <see cref="ColorSliderImage.RegenerateTexture"/>
    /// </summary>
    private void RegenerateTexture(MapEvent.ChromaGradient gradient)
    {
        Color startColor = gradient.StartColor;
        Color endColor = gradient.EndColor;

        Texture2D texture = Create(new Color[] { startColor, endColor }, gradient);
        currentTex = texture;

        Sprite sprite = Sprite.Create(texture, new Rect(0, 0, texture.width, texture.height), Vector2.one / 2f, size);
        sprite.name = "Autogenerated Gradient";
        spriteRenderer.sprite = sprite;
    }

    private static Texture2D Create(Color[] colors, MapEvent.ChromaGradient chromaGradient, TextureWrapMode textureWrapMode = TextureWrapMode.Clamp, FilterMode filterMode = FilterMode.Point, bool isLinear = false, bool hasMipMap = false)
    {
        if (colors == null || colors.Length == 0)
        {
            Debug.LogError("No colors assigned");
            return null;
        }

        int length = colors.Length;
        if (colors.Length > 8)
        {
            Debug.LogWarning("Too many colors! maximum is 8, assigned: " + colors.Length);
            length = 8;
        }

        // build gradient from colors
        var colorKeys = new GradientColorKey[length];
        var alphaKeys = new GradientAlphaKey[length];

        float steps = length - 1f;
        for (int i = 0; i < length; i++)
        {
            float step = i / steps;
            colorKeys[i].color = colors[i];
            colorKeys[i].time = step;
            alphaKeys[i].alpha = colors[i].a;
            alphaKeys[i].time = step;
        }

        // create gradient
        Gradient gradient = new Gradient();
        gradient.SetKeys(colorKeys, alphaKeys);

        // create texture
        Texture2D outputTex = new Texture2D(256, 1, TextureFormat.ARGB32, hasMipMap, isLinear);
        outputTex.wrapMode = textureWrapMode;
        outputTex.filterMode = filterMode;

        var easing = Easing.byName[chromaGradient.EasingType];
        // draw texture
        for (int i = 0; i < size; i++)
        {
            outputTex.SetPixel(i, 0, gradient.Evaluate(easing((float)i / size)));
        }
        outputTex.Apply(false);

        return outputTex;
    } // BuildGradientTexture
}
